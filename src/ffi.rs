/* automatically generated by rust-bindgen 0.71.1 */

use libc::FILE;
pub type OPJ_BYTE = u8;

pub const OPJ_TRUE: u32 = 1;
pub const OPJ_FALSE: u32 = 0;
pub const OPJ_HAVE_STDINT_H: u32 = 1;
pub const OPJ_VERSION_MAJOR: u32 = 2;
pub const OPJ_VERSION_MINOR: u32 = 5;
pub const OPJ_VERSION_BUILD: u32 = 2;
pub const OPJ_PATH_LEN: u32 = 4096;
pub const OPJ_J2K_MAXRLVLS: u32 = 33;
pub const OPJ_J2K_MAXBANDS: u32 = 97;
pub const OPJ_J2K_DEFAULT_NB_SEGS: u32 = 10;
pub const OPJ_J2K_STREAM_CHUNK_SIZE: u32 = 1048576;
pub const OPJ_J2K_DEFAULT_HEADER_SIZE: u32 = 1000;
pub const OPJ_J2K_MCC_DEFAULT_NB_RECORDS: u32 = 10;
pub const OPJ_J2K_MCT_DEFAULT_NB_RECORDS: u32 = 10;
pub const OPJ_IMG_INFO: u32 = 1;
pub const OPJ_J2K_MH_INFO: u32 = 2;
pub const OPJ_J2K_TH_INFO: u32 = 4;
pub const OPJ_J2K_TCH_INFO: u32 = 8;
pub const OPJ_J2K_MH_IND: u32 = 16;
pub const OPJ_J2K_TH_IND: u32 = 32;
pub const OPJ_JP2_INFO: u32 = 128;
pub const OPJ_JP2_IND: u32 = 256;
pub const OPJ_PROFILE_NONE: u32 = 0;
pub const OPJ_PROFILE_0: u32 = 1;
pub const OPJ_PROFILE_1: u32 = 2;
pub const OPJ_PROFILE_PART2: u32 = 32768;
pub const OPJ_PROFILE_CINEMA_2K: u32 = 3;
pub const OPJ_PROFILE_CINEMA_4K: u32 = 4;
pub const OPJ_PROFILE_CINEMA_S2K: u32 = 5;
pub const OPJ_PROFILE_CINEMA_S4K: u32 = 6;
pub const OPJ_PROFILE_CINEMA_LTS: u32 = 7;
pub const OPJ_PROFILE_BC_SINGLE: u32 = 256;
pub const OPJ_PROFILE_BC_MULTI: u32 = 512;
pub const OPJ_PROFILE_BC_MULTI_R: u32 = 768;
pub const OPJ_PROFILE_IMF_2K: u32 = 1024;
pub const OPJ_PROFILE_IMF_4K: u32 = 1280;
pub const OPJ_PROFILE_IMF_8K: u32 = 1536;
pub const OPJ_PROFILE_IMF_2K_R: u32 = 1792;
pub const OPJ_PROFILE_IMF_4K_R: u32 = 2048;
pub const OPJ_PROFILE_IMF_8K_R: u32 = 2304;
pub const OPJ_EXTENSION_NONE: u32 = 0;
pub const OPJ_EXTENSION_MCT: u32 = 256;
pub const OPJ_IMF_MAINLEVEL_MAX: u32 = 11;
pub const OPJ_IMF_MAINLEVEL_1_MSAMPLESEC: u32 = 65;
pub const OPJ_IMF_MAINLEVEL_2_MSAMPLESEC: u32 = 130;
pub const OPJ_IMF_MAINLEVEL_3_MSAMPLESEC: u32 = 195;
pub const OPJ_IMF_MAINLEVEL_4_MSAMPLESEC: u32 = 260;
pub const OPJ_IMF_MAINLEVEL_5_MSAMPLESEC: u32 = 520;
pub const OPJ_IMF_MAINLEVEL_6_MSAMPLESEC: u32 = 1200;
pub const OPJ_IMF_MAINLEVEL_7_MSAMPLESEC: u32 = 2400;
pub const OPJ_IMF_MAINLEVEL_8_MSAMPLESEC: u32 = 4800;
pub const OPJ_IMF_MAINLEVEL_9_MSAMPLESEC: u32 = 9600;
pub const OPJ_IMF_MAINLEVEL_10_MSAMPLESEC: u32 = 19200;
pub const OPJ_IMF_MAINLEVEL_11_MSAMPLESEC: u32 = 38400;
pub const OPJ_IMF_SUBLEVEL_1_MBITSSEC: u32 = 200;
pub const OPJ_IMF_SUBLEVEL_2_MBITSSEC: u32 = 400;
pub const OPJ_IMF_SUBLEVEL_3_MBITSSEC: u32 = 800;
pub const OPJ_IMF_SUBLEVEL_4_MBITSSEC: u32 = 1600;
pub const OPJ_IMF_SUBLEVEL_5_MBITSSEC: u32 = 3200;
pub const OPJ_IMF_SUBLEVEL_6_MBITSSEC: u32 = 6400;
pub const OPJ_IMF_SUBLEVEL_7_MBITSSEC: u32 = 12800;
pub const OPJ_IMF_SUBLEVEL_8_MBITSSEC: u32 = 25600;
pub const OPJ_IMF_SUBLEVEL_9_MBITSSEC: u32 = 51200;
pub const OPJ_CINEMA_24_CS: u32 = 1302083;
pub const OPJ_CINEMA_48_CS: u32 = 651041;
pub const OPJ_CINEMA_24_COMP: u32 = 1041666;
pub const OPJ_CINEMA_48_COMP: u32 = 520833;
pub const OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG: u32 = 1;
pub const OPJ_DPARAMETERS_DUMP_FLAG: u32 = 2;
pub const OPJ_STREAM_READ: u32 = 1;
pub const OPJ_STREAM_WRITE: u32 = 0;
pub type OPJ_BOOL = ::std::os::raw::c_int;
pub type OPJ_CHAR = ::std::os::raw::c_char;
pub type OPJ_FLOAT32 = f32;
pub type OPJ_UINT16 = u16;
pub type OPJ_INT32 = i32;
pub type OPJ_UINT32 = u32;
pub type OPJ_UINT64 = u64;
pub type OPJ_OFF_T = i64;
pub type OPJ_SIZE_T = usize;
#[repr(u32)]
#[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead\nRsiz Capabilities"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RSIZ_CAPABILITIES {
    OPJ_STD_RSIZ = 0,
    #[doc = "Standard JPEG2000 profile"]
    OPJ_CINEMA2K = 3,
    #[doc = "Profile name for a 2K image"]
    OPJ_CINEMA4K = 4,
    #[doc = "Profile name for a 4K image"]
    OPJ_MCT = 33024,
}
#[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead\nRsiz Capabilities"]
pub use self::RSIZ_CAPABILITIES as OPJ_RSIZ_CAPABILITIES;
#[repr(u32)]
#[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead\nDigital cinema operation mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CINEMA_MODE {
    OPJ_OFF = 0,
    #[doc = "Not Digital Cinema"]
    OPJ_CINEMA2K_24 = 1,
    #[doc = "2K Digital Cinema at 24 fps"]
    OPJ_CINEMA2K_48 = 2,
    #[doc = "2K Digital Cinema at 48 fps"]
    OPJ_CINEMA4K_24 = 3,
}
#[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead\nDigital cinema operation mode"]
pub use self::CINEMA_MODE as OPJ_CINEMA_MODE;
#[repr(i32)]
#[doc = "Progression order"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PROG_ORDER {
    #[doc = "< place-holder"]
    OPJ_PROG_UNKNOWN = -1,
    #[doc = "< layer-resolution-component-precinct order"]
    OPJ_LRCP = 0,
    #[doc = "< resolution-layer-component-precinct order"]
    OPJ_RLCP = 1,
    #[doc = "< resolution-precinct-component-layer order"]
    OPJ_RPCL = 2,
    #[doc = "< precinct-component-resolution-layer order"]
    OPJ_PCRL = 3,
    #[doc = "< component-precinct-resolution-layer order"]
    OPJ_CPRL = 4,
}
#[doc = "Progression order"]
pub use self::PROG_ORDER as OPJ_PROG_ORDER;
#[repr(i32)]
#[doc = "Supported image color spaces"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum COLOR_SPACE {
    #[doc = "< not supported by the library"]
    OPJ_CLRSPC_UNKNOWN = -1,
    #[doc = "< not specified in the codestream"]
    OPJ_CLRSPC_UNSPECIFIED = 0,
    #[doc = "< sRGB"]
    OPJ_CLRSPC_SRGB = 1,
    #[doc = "< grayscale"]
    OPJ_CLRSPC_GRAY = 2,
    #[doc = "< YUV"]
    OPJ_CLRSPC_SYCC = 3,
    #[doc = "< e-YCC"]
    OPJ_CLRSPC_EYCC = 4,
    #[doc = "< CMYK"]
    OPJ_CLRSPC_CMYK = 5,
}
#[doc = "Supported image color spaces"]
pub use self::COLOR_SPACE as OPJ_COLOR_SPACE;
#[repr(i32)]
#[doc = "Supported codec"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CODEC_FORMAT {
    #[doc = "< place-holder"]
    OPJ_CODEC_UNKNOWN = -1,
    #[doc = "< JPEG-2000 codestream : read/write"]
    OPJ_CODEC_J2K = 0,
    #[doc = "< JPT-stream (JPEG 2000, JPIP) : read only"]
    OPJ_CODEC_JPT = 1,
    #[doc = "< JP2 file format : read/write"]
    OPJ_CODEC_JP2 = 2,
    #[doc = "< JPP-stream (JPEG 2000, JPIP) : to be coded"]
    OPJ_CODEC_JPP = 3,
    #[doc = "< JPX file format (JPEG 2000 Part-2) : to be coded"]
    OPJ_CODEC_JPX = 4,
}
#[doc = "Supported codec"]
pub use self::CODEC_FORMAT as OPJ_CODEC_FORMAT;
#[doc = "Callback function prototype for events\n# Arguments\n\n* `msg` -               Event message\n* `client_data` -       Client object where will be return the event message"]
pub type opj_msg_callback = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const ::std::os::raw::c_char,
        client_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "Progression order changes\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_poc {
    #[doc = "Resolution num start, Component num start, given by POC"]
    pub resno0: OPJ_UINT32,
    #[doc = "Resolution num start, Component num start, given by POC"]
    pub compno0: OPJ_UINT32,
    #[doc = "Layer num end,Resolution num end, Component num end, given by POC"]
    pub layno1: OPJ_UINT32,
    #[doc = "Layer num end,Resolution num end, Component num end, given by POC"]
    pub resno1: OPJ_UINT32,
    #[doc = "Layer num end,Resolution num end, Component num end, given by POC"]
    pub compno1: OPJ_UINT32,
    #[doc = "Layer num start,Precinct num start, Precinct num end"]
    pub layno0: OPJ_UINT32,
    #[doc = "Layer num start,Precinct num start, Precinct num end"]
    pub precno0: OPJ_UINT32,
    #[doc = "Layer num start,Precinct num start, Precinct num end"]
    pub precno1: OPJ_UINT32,
    #[doc = "Progression order enum"]
    pub prg1: OPJ_PROG_ORDER,
    #[doc = "Progression order enum"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = "Progression order string"]
    pub progorder: [OPJ_CHAR; 5usize],
    #[doc = "Tile number (starting at 1)"]
    pub tile: OPJ_UINT32,
    #[doc = "Start and end values for Tile width and height"]
    pub tx0: OPJ_INT32,
    #[doc = "Start and end values for Tile width and height"]
    pub tx1: OPJ_INT32,
    #[doc = "Start and end values for Tile width and height"]
    pub ty0: OPJ_INT32,
    #[doc = "Start and end values for Tile width and height"]
    pub ty1: OPJ_INT32,
    #[doc = "Start value, initialised in pi_initialise_encode"]
    pub layS: OPJ_UINT32,
    #[doc = "Start value, initialised in pi_initialise_encode"]
    pub resS: OPJ_UINT32,
    #[doc = "Start value, initialised in pi_initialise_encode"]
    pub compS: OPJ_UINT32,
    #[doc = "Start value, initialised in pi_initialise_encode"]
    pub prcS: OPJ_UINT32,
    #[doc = "End value, initialised in pi_initialise_encode"]
    pub layE: OPJ_UINT32,
    #[doc = "End value, initialised in pi_initialise_encode"]
    pub resE: OPJ_UINT32,
    #[doc = "End value, initialised in pi_initialise_encode"]
    pub compE: OPJ_UINT32,
    #[doc = "End value, initialised in pi_initialise_encode"]
    pub prcE: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txS: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub txE: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyS: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub tyE: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dx: OPJ_UINT32,
    #[doc = "Start and end values of Tile width and height, initialised in pi_initialise_encode"]
    pub dy: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub lay_t: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub res_t: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub comp_t: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub prc_t: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub tx0_t: OPJ_UINT32,
    #[doc = "Temporary values for Tile parts, initialised in pi_create_encode"]
    pub ty0_t: OPJ_UINT32,
}
#[doc = "Progression order changes\n"]
pub type opj_poc_t = opj_poc;
#[doc = "Compression parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_cparameters {
    #[doc = "size of tile: tile_size_on = false (not in argument) or = true (in argument)"]
    pub tile_size_on: OPJ_BOOL,
    #[doc = "XTOsiz"]
    pub cp_tx0: ::std::os::raw::c_int,
    #[doc = "YTOsiz"]
    pub cp_ty0: ::std::os::raw::c_int,
    #[doc = "XTsiz"]
    pub cp_tdx: ::std::os::raw::c_int,
    #[doc = "YTsiz"]
    pub cp_tdy: ::std::os::raw::c_int,
    #[doc = "allocation by rate/distortion"]
    pub cp_disto_alloc: ::std::os::raw::c_int,
    #[doc = "allocation by fixed layer"]
    pub cp_fixed_alloc: ::std::os::raw::c_int,
    #[doc = "allocation by fixed quality (PSNR)"]
    pub cp_fixed_quality: ::std::os::raw::c_int,
    #[doc = "fixed layer"]
    pub cp_matrice: *mut ::std::os::raw::c_int,
    #[doc = "comment for coding"]
    pub cp_comment: *mut ::std::os::raw::c_char,
    #[doc = "csty : coding style"]
    pub csty: ::std::os::raw::c_int,
    #[doc = "progression order (default OPJ_LRCP)"]
    pub prog_order: OPJ_PROG_ORDER,
    #[doc = "progression order changes"]
    pub POC: [opj_poc_t; 32usize],
    #[doc = "number of progression order changes (POC), default to 0"]
    pub numpocs: OPJ_UINT32,
    #[doc = "number of layers"]
    pub tcp_numlayers: ::std::os::raw::c_int,
    #[doc = "rates of layers - might be subsequently limited by the max_cs_size field.\nShould be decreasing. 1 can be\nused as last value to indicate the last layer is lossless."]
    pub tcp_rates: [f32; 100usize],
    #[doc = "different psnr for successive layers. Should be increasing. 0 can be\nused as last value to indicate the last layer is lossless."]
    pub tcp_distoratio: [f32; 100usize],
    #[doc = "number of resolutions"]
    pub numresolution: ::std::os::raw::c_int,
    #[doc = "initial code block width, default to 64"]
    pub cblockw_init: ::std::os::raw::c_int,
    #[doc = "initial code block height, default to 64"]
    pub cblockh_init: ::std::os::raw::c_int,
    #[doc = "mode switch (cblk_style)"]
    pub mode: ::std::os::raw::c_int,
    #[doc = "1 : use the irreversible DWT 9-7, 0 : use lossless compression (default)"]
    pub irreversible: ::std::os::raw::c_int,
    #[doc = "region of interest: affected component in [0..3], -1 means no ROI"]
    pub roi_compno: ::std::os::raw::c_int,
    #[doc = "region of interest: upshift value"]
    pub roi_shift: ::std::os::raw::c_int,
    pub res_spec: ::std::os::raw::c_int,
    #[doc = "initial precinct width"]
    pub prcw_init: [::std::os::raw::c_int; 33usize],
    #[doc = "initial precinct height"]
    pub prch_init: [::std::os::raw::c_int; 33usize],
    #[doc = "input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = "output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = "DEPRECATED. Index generation is now handled with the opj_encode_with_info() function. Set to NULL"]
    pub index_on: ::std::os::raw::c_int,
    #[doc = "DEPRECATED. Index generation is now handled with the opj_encode_with_info() function. Set to NULL"]
    pub index: [::std::os::raw::c_char; 4096usize],
    #[doc = "subimage encoding: origin image offset in x direction"]
    pub image_offset_x0: ::std::os::raw::c_int,
    #[doc = "subimage encoding: origin image offset in y direction"]
    pub image_offset_y0: ::std::os::raw::c_int,
    #[doc = "subsampling value for dx"]
    pub subsampling_dx: ::std::os::raw::c_int,
    #[doc = "subsampling value for dy"]
    pub subsampling_dy: ::std::os::raw::c_int,
    #[doc = "input file format 0: PGX, 1: PxM, 2: BMP 3:TIF"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = "output file format 0: J2K, 1: JP2, 2: JPT"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = "enables writing of EPC in MH, thus activating JPWL"]
    pub jpwl_epc_on: OPJ_BOOL,
    #[doc = "error protection method for MH (0,1,16,32,37-128)"]
    pub jpwl_hprot_MH: ::std::os::raw::c_int,
    #[doc = "tile number of header protection specification (>=0)"]
    pub jpwl_hprot_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = "error protection methods for TPHs (0,1,16,32,37-128)"]
    pub jpwl_hprot_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = "tile number of packet protection specification (>=0)"]
    pub jpwl_pprot_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = "packet number of packet protection specification (>=0)"]
    pub jpwl_pprot_packno: [::std::os::raw::c_int; 16usize],
    #[doc = "error protection methods for packets (0,1,16,32,37-128)"]
    pub jpwl_pprot: [::std::os::raw::c_int; 16usize],
    #[doc = "enables writing of ESD, (0=no/1/2 bytes)"]
    pub jpwl_sens_size: ::std::os::raw::c_int,
    #[doc = "sensitivity addressing size (0=auto/2/4 bytes)"]
    pub jpwl_sens_addr: ::std::os::raw::c_int,
    #[doc = "sensitivity range (0-3)"]
    pub jpwl_sens_range: ::std::os::raw::c_int,
    #[doc = "sensitivity method for MH (-1=no,0-7)"]
    pub jpwl_sens_MH: ::std::os::raw::c_int,
    #[doc = "tile number of sensitivity specification (>=0)"]
    pub jpwl_sens_TPH_tileno: [::std::os::raw::c_int; 16usize],
    #[doc = "sensitivity methods for TPHs (-1=no,0-7)"]
    pub jpwl_sens_TPH: [::std::os::raw::c_int; 16usize],
    #[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and MAX_COMP_SIZE instead\nDigital Cinema compliance 0-not compliant, 1-compliant"]
    pub cp_cinema: OPJ_CINEMA_MODE,
    #[doc = "Maximum size (in bytes) for each component.\nIf == 0, component size limitation is not considered"]
    pub max_comp_size: ::std::os::raw::c_int,
    #[doc = "DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead\nProfile name"]
    pub cp_rsiz: OPJ_RSIZ_CAPABILITIES,
    #[doc = "Tile part generation"]
    pub tp_on: ::std::os::raw::c_char,
    #[doc = "Flag for Tile part generation"]
    pub tp_flag: ::std::os::raw::c_char,
    #[doc = "MCT (multiple component transform)"]
    pub tcp_mct: ::std::os::raw::c_char,
    #[doc = "Enable JPIP indexing"]
    pub jpip_on: OPJ_BOOL,
    #[doc = "Naive implementation of MCT restricted to a single reversible array based\nencoding without offset concerning all the components."]
    pub mct_data: *mut ::std::os::raw::c_void,
    #[doc = "Maximum size (in bytes) for the whole codestream.\nIf == 0, codestream size limitation is not considered\nIf it does not comply with tcp_rates, max_cs_size prevails\nand a warning is issued."]
    pub max_cs_size: ::std::os::raw::c_int,
    #[doc = "RSIZ value\nTo be used to combine OPJ_PROFILE_*, OPJ_EXTENSION_* and (sub)levels values."]
    pub rsiz: OPJ_UINT16,
}
#[doc = "Compression parameters"]
pub type opj_cparameters_t = opj_cparameters;
#[doc = "Decompression parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_dparameters {
    #[doc = "Set the number of highest resolution levels to be discarded.\nThe image resolution is effectively divided by 2 to the power of the number of discarded levels.\nThe reduce factor is limited by the smallest total number of decomposition levels among tiles.\nif != 0, then original dimension divided by 2^(reduce);\nif == 0 or not used, image is decoded to the full resolution"]
    pub cp_reduce: OPJ_UINT32,
    #[doc = "Set the maximum number of quality layers to decode.\nIf there are less quality layers than the specified number, all the quality layers are decoded.\nif != 0, then only the first \"layer\" layers are decoded;\nif == 0 or not used, all the quality layers are decoded"]
    pub cp_layer: OPJ_UINT32,
    #[doc = "input file name"]
    pub infile: [::std::os::raw::c_char; 4096usize],
    #[doc = "output file name"]
    pub outfile: [::std::os::raw::c_char; 4096usize],
    #[doc = "input file format 0: J2K, 1: JP2, 2: JPT"]
    pub decod_format: ::std::os::raw::c_int,
    #[doc = "output file format 0: PGX, 1: PxM, 2: BMP"]
    pub cod_format: ::std::os::raw::c_int,
    #[doc = "Decoding area left boundary"]
    pub DA_x0: OPJ_UINT32,
    #[doc = "Decoding area right boundary"]
    pub DA_x1: OPJ_UINT32,
    #[doc = "Decoding area up boundary"]
    pub DA_y0: OPJ_UINT32,
    #[doc = "Decoding area bottom boundary"]
    pub DA_y1: OPJ_UINT32,
    #[doc = "Verbose mode"]
    pub m_verbose: OPJ_BOOL,
    #[doc = "tile number of the decoded tile"]
    pub tile_index: OPJ_UINT32,
    #[doc = "Nb of tile to decode"]
    pub nb_tile_to_decode: OPJ_UINT32,
    #[doc = "activates the JPWL correction capabilities"]
    pub jpwl_correct: OPJ_BOOL,
    #[doc = "expected number of components"]
    pub jpwl_exp_comps: ::std::os::raw::c_int,
    #[doc = "maximum number of tiles"]
    pub jpwl_max_tiles: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
#[doc = "Decompression parameters"]
pub type opj_dparameters_t = opj_dparameters;
#[doc = "JPEG2000 codec V2."]
pub type opj_codec_t = *mut ::std::os::raw::c_void;
pub type opj_stream_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_buffer: *mut ::std::os::raw::c_void,
        p_nb_bytes: OPJ_SIZE_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_SIZE_T,
>;
pub type opj_stream_skip_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_OFF_T,
>;
pub type opj_stream_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        p_nb_bytes: OPJ_OFF_T,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL,
>;
pub type opj_stream_free_user_data_fn =
    ::std::option::Option<unsafe extern "C" fn(p_user_data: *mut ::std::os::raw::c_void)>;
pub type opj_stream_t = *mut ::std::os::raw::c_void;
#[doc = "Defines a single image component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comp {
    #[doc = "XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = "YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = "data width"]
    pub w: OPJ_UINT32,
    #[doc = "data height"]
    pub h: OPJ_UINT32,
    #[doc = "x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = "y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = "precision: number of bits per component per pixel"]
    pub prec: OPJ_UINT32,
    #[doc = "obsolete: use prec instead"]
    pub bpp: OPJ_UINT32,
    #[doc = "signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
    #[doc = "number of decoded resolution"]
    pub resno_decoded: OPJ_UINT32,
    #[doc = "number of division by 2 of the out image compared to the original size of image"]
    pub factor: OPJ_UINT32,
    #[doc = "image component data"]
    pub data: *mut OPJ_INT32,
    #[doc = "alpha channel"]
    pub alpha: OPJ_UINT16,
}
#[doc = "Defines a single image component"]
pub type opj_image_comp_t = opj_image_comp;
#[doc = "Defines image data and characteristics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image {
    #[doc = "XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area"]
    pub x0: OPJ_UINT32,
    #[doc = "YOsiz: vertical offset from the origin of the reference grid to the top side of the image area"]
    pub y0: OPJ_UINT32,
    #[doc = "Xsiz: width of the reference grid"]
    pub x1: OPJ_UINT32,
    #[doc = "Ysiz: height of the reference grid"]
    pub y1: OPJ_UINT32,
    #[doc = "number of components in the image"]
    pub numcomps: OPJ_UINT32,
    #[doc = "color space: sRGB, Greyscale or YUV"]
    pub color_space: OPJ_COLOR_SPACE,
    #[doc = "image components"]
    pub comps: *mut opj_image_comp_t,
    #[doc = "'restricted' ICC profile"]
    pub icc_profile_buf: *mut OPJ_BYTE,
    #[doc = "size of ICC profile"]
    pub icc_profile_len: OPJ_UINT32,
}
#[doc = "Defines image data and characteristics"]
pub type opj_image_t = opj_image;
#[doc = "Component parameters structure used by the opj_image_create function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_image_comptparm {
    #[doc = "XRsiz: horizontal separation of a sample of ith component with respect to the reference grid"]
    pub dx: OPJ_UINT32,
    #[doc = "YRsiz: vertical separation of a sample of ith component with respect to the reference grid"]
    pub dy: OPJ_UINT32,
    #[doc = "data width"]
    pub w: OPJ_UINT32,
    #[doc = "data height"]
    pub h: OPJ_UINT32,
    #[doc = "x component offset compared to the whole image"]
    pub x0: OPJ_UINT32,
    #[doc = "y component offset compared to the whole image"]
    pub y0: OPJ_UINT32,
    #[doc = "precision: number of bits per component per pixel"]
    pub prec: OPJ_UINT32,
    #[doc = "obsolete: use prec instead"]
    pub bpp: OPJ_UINT32,
    #[doc = "signed (1) / unsigned (0)"]
    pub sgnd: OPJ_UINT32,
}
#[doc = "Component parameters structure used by the opj_image_create function"]
pub type opj_image_cmptparm_t = opj_image_comptparm;
#[doc = "Index structure : Information concerning a packet inside tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_packet_info {
    #[doc = "packet start position (including SOP marker if it exists)"]
    pub start_pos: OPJ_OFF_T,
    #[doc = "end of packet header position (including EPH marker if it exists)"]
    pub end_ph_pos: OPJ_OFF_T,
    #[doc = "packet end position"]
    pub end_pos: OPJ_OFF_T,
    #[doc = "packet distortion"]
    pub disto: f64,
}
#[doc = "Index structure : Information concerning a packet inside tile"]
pub type opj_packet_info_t = opj_packet_info;
#[doc = "Marker structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_marker_info {
    #[doc = "marker type"]
    pub type_: ::std::os::raw::c_ushort,
    #[doc = "position in codestream"]
    pub pos: OPJ_OFF_T,
    #[doc = "length, marker val included"]
    pub len: ::std::os::raw::c_int,
}
#[doc = "Marker structure"]
pub type opj_marker_info_t = opj_marker_info;
#[doc = "Index structure : Information concerning tile-parts"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_info {
    #[doc = "start position of tile part"]
    pub tp_start_pos: ::std::os::raw::c_int,
    #[doc = "end position of tile part header"]
    pub tp_end_header: ::std::os::raw::c_int,
    #[doc = "end position of tile part"]
    pub tp_end_pos: ::std::os::raw::c_int,
    #[doc = "start packet of tile part"]
    pub tp_start_pack: ::std::os::raw::c_int,
    #[doc = "number of packets of tile part"]
    pub tp_numpacks: ::std::os::raw::c_int,
}
#[doc = "Index structure : Information concerning tile-parts"]
pub type opj_tp_info_t = opj_tp_info;
#[doc = "Index structure : information regarding tiles"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_info {
    #[doc = "value of thresh for each layer by tile cfr. Marcela"]
    pub thresh: *mut f64,
    #[doc = "number of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = "start position"]
    pub start_pos: ::std::os::raw::c_int,
    #[doc = "end position of the header"]
    pub end_header: ::std::os::raw::c_int,
    #[doc = "end position"]
    pub end_pos: ::std::os::raw::c_int,
    #[doc = "precinct number for each resolution level (width)"]
    pub pw: [::std::os::raw::c_int; 33usize],
    #[doc = "precinct number for each resolution level (height)"]
    pub ph: [::std::os::raw::c_int; 33usize],
    #[doc = "precinct size (in power of 2), in X for each resolution level"]
    pub pdx: [::std::os::raw::c_int; 33usize],
    #[doc = "precinct size (in power of 2), in Y for each resolution level"]
    pub pdy: [::std::os::raw::c_int; 33usize],
    #[doc = "information concerning packets inside tile"]
    pub packet: *mut opj_packet_info_t,
    #[doc = "number of pixels of the tile"]
    pub numpix: ::std::os::raw::c_int,
    #[doc = "distortion of the tile"]
    pub distotile: f64,
    #[doc = "number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = "list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = "actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = "number of tile parts"]
    pub num_tps: ::std::os::raw::c_int,
    #[doc = "information concerning tile parts"]
    pub tp: *mut opj_tp_info_t,
}
#[doc = "Index structure : information regarding tiles"]
pub type opj_tile_info_t = opj_tile_info;
#[doc = "Index structure of the codestream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info {
    #[doc = "maximum distortion reduction on the whole image (add for Marcela)"]
    pub D_max: f64,
    #[doc = "packet number"]
    pub packno: ::std::os::raw::c_int,
    #[doc = "writing the packet in the index with t2_encode_packets"]
    pub index_write: ::std::os::raw::c_int,
    #[doc = "image width"]
    pub image_w: ::std::os::raw::c_int,
    #[doc = "image height"]
    pub image_h: ::std::os::raw::c_int,
    #[doc = "progression order"]
    pub prog: OPJ_PROG_ORDER,
    #[doc = "tile size in x"]
    pub tile_x: ::std::os::raw::c_int,
    #[doc = "tile size in y"]
    pub tile_y: ::std::os::raw::c_int,
    pub tile_Ox: ::std::os::raw::c_int,
    pub tile_Oy: ::std::os::raw::c_int,
    #[doc = "number of tiles in X"]
    pub tw: ::std::os::raw::c_int,
    #[doc = "number of tiles in Y"]
    pub th: ::std::os::raw::c_int,
    #[doc = "component numbers"]
    pub numcomps: ::std::os::raw::c_int,
    #[doc = "number of layer"]
    pub numlayers: ::std::os::raw::c_int,
    #[doc = "number of decomposition for each component"]
    pub numdecompos: *mut ::std::os::raw::c_int,
    #[doc = "number of markers"]
    pub marknum: ::std::os::raw::c_int,
    #[doc = "list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = "actual size of markers array"]
    pub maxmarknum: ::std::os::raw::c_int,
    #[doc = "main header position"]
    pub main_head_start: ::std::os::raw::c_int,
    #[doc = "main header position"]
    pub main_head_end: ::std::os::raw::c_int,
    #[doc = "codestream's size"]
    pub codestream_size: ::std::os::raw::c_int,
    #[doc = "information regarding tiles inside image"]
    pub tile: *mut opj_tile_info_t,
}
#[doc = "Index structure of the codestream"]
pub type opj_codestream_info_t = opj_codestream_info;
#[doc = "Tile-component coding parameters information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tccp_info {
    #[doc = "component index"]
    pub compno: OPJ_UINT32,
    #[doc = "coding style"]
    pub csty: OPJ_UINT32,
    #[doc = "number of resolutions"]
    pub numresolutions: OPJ_UINT32,
    #[doc = "log2 of code-blocks width"]
    pub cblkw: OPJ_UINT32,
    #[doc = "log2 of code-blocks height"]
    pub cblkh: OPJ_UINT32,
    #[doc = "code-block coding style"]
    pub cblksty: OPJ_UINT32,
    #[doc = "discrete wavelet transform identifier: 0 = 9-7 irreversible, 1 = 5-3 reversible"]
    pub qmfbid: OPJ_UINT32,
    #[doc = "quantisation style"]
    pub qntsty: OPJ_UINT32,
    #[doc = "stepsizes used for quantization"]
    pub stepsizes_mant: [OPJ_UINT32; 97usize],
    #[doc = "stepsizes used for quantization"]
    pub stepsizes_expn: [OPJ_UINT32; 97usize],
    #[doc = "number of guard bits"]
    pub numgbits: OPJ_UINT32,
    #[doc = "Region Of Interest shift"]
    pub roishift: OPJ_INT32,
    #[doc = "precinct width"]
    pub prcw: [OPJ_UINT32; 33usize],
    #[doc = "precinct height"]
    pub prch: [OPJ_UINT32; 33usize],
}
#[doc = "Tile-component coding parameters information"]
pub type opj_tccp_info_t = opj_tccp_info;
#[doc = "Tile coding parameters information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_v2_info {
    #[doc = "number (index) of tile"]
    pub tileno: ::std::os::raw::c_int,
    #[doc = "coding style"]
    pub csty: OPJ_UINT32,
    #[doc = "progression order"]
    pub prg: OPJ_PROG_ORDER,
    #[doc = "number of layers"]
    pub numlayers: OPJ_UINT32,
    #[doc = "multi-component transform identifier"]
    pub mct: OPJ_UINT32,
    #[doc = "information concerning tile component parameters"]
    pub tccp_info: *mut opj_tccp_info_t,
}
#[doc = "Tile coding parameters information"]
pub type opj_tile_info_v2_t = opj_tile_v2_info;
#[doc = "Information structure about the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_info_v2 {
    #[doc = "tile origin in x = XTOsiz"]
    pub tx0: OPJ_UINT32,
    #[doc = "tile origin in y = YTOsiz"]
    pub ty0: OPJ_UINT32,
    #[doc = "tile size in x = XTsiz"]
    pub tdx: OPJ_UINT32,
    #[doc = "tile size in y = YTsiz"]
    pub tdy: OPJ_UINT32,
    #[doc = "number of tiles in X"]
    pub tw: OPJ_UINT32,
    #[doc = "number of tiles in Y"]
    pub th: OPJ_UINT32,
    #[doc = "number of components"]
    pub nbcomps: OPJ_UINT32,
    #[doc = "Default information regarding tiles inside image"]
    pub m_default_tile_info: opj_tile_info_v2_t,
    #[doc = "information regarding tiles inside image"]
    pub tile_info: *mut opj_tile_info_v2_t,
}
#[doc = "Information structure about the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_info_v2_t = opj_codestream_info_v2;
#[doc = "Index structure about a tile part"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tp_index {
    #[doc = "start position"]
    pub start_pos: OPJ_OFF_T,
    #[doc = "end position of the header"]
    pub end_header: OPJ_OFF_T,
    #[doc = "end position"]
    pub end_pos: OPJ_OFF_T,
}
#[doc = "Index structure about a tile part"]
pub type opj_tp_index_t = opj_tp_index;
#[doc = "Index structure about a tile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_tile_index {
    #[doc = "tile index"]
    pub tileno: OPJ_UINT32,
    #[doc = "number of tile parts"]
    pub nb_tps: OPJ_UINT32,
    #[doc = "current nb of tile part (allocated)"]
    pub current_nb_tps: OPJ_UINT32,
    #[doc = "current tile-part index"]
    pub current_tpsno: OPJ_UINT32,
    #[doc = "information concerning tile parts"]
    pub tp_index: *mut opj_tp_index_t,
    #[doc = "number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = "list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = "actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    #[doc = "packet number"]
    pub nb_packet: OPJ_UINT32,
    #[doc = "information concerning packets inside tile"]
    pub packet_index: *mut opj_packet_info_t,
}
#[doc = "Index structure about a tile"]
pub type opj_tile_index_t = opj_tile_index;
#[doc = "Index structure of the codestream (FIXME should be expand and enhance)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_codestream_index {
    #[doc = "main header start position (SOC position)"]
    pub main_head_start: OPJ_OFF_T,
    #[doc = "main header end position (first SOT position)"]
    pub main_head_end: OPJ_OFF_T,
    #[doc = "codestream's size"]
    pub codestream_size: OPJ_UINT64,
    #[doc = "number of markers"]
    pub marknum: OPJ_UINT32,
    #[doc = "list of markers"]
    pub marker: *mut opj_marker_info_t,
    #[doc = "actual size of markers array"]
    pub maxmarknum: OPJ_UINT32,
    pub nb_of_tiles: OPJ_UINT32,
    pub tile_index: *mut opj_tile_index_t,
}
#[doc = "Index structure of the codestream (FIXME should be expand and enhance)"]
pub type opj_codestream_index_t = opj_codestream_index;
#[doc = "Info structure of the JP2 file\nEXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_metadata {
    pub not_used: OPJ_INT32,
}
#[doc = "Info structure of the JP2 file\nEXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_metadata_t = opj_jp2_metadata;
#[doc = "Index structure of the JP2 file\nEXPERIMENTAL FOR THE MOMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opj_jp2_index {
    pub not_used: OPJ_INT32,
}
#[doc = "Index structure of the JP2 file\nEXPERIMENTAL FOR THE MOMENT"]
pub type opj_jp2_index_t = opj_jp2_index;
extern "C" {
    pub fn opj_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Create an image\n# Arguments\n\n* `numcmpts` -      number of components\n* `cmptparms` -     components parameters\n* `clrspc` -        image color space\n# Returns\n\nreturns      a new image structure if successful, returns NULL otherwise"]
    pub fn opj_image_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = "Deallocate any resources associated with an image\n# Arguments\n\n* `image` -         image to be destroyed"]
    pub fn opj_image_destroy(image: *mut opj_image_t);
}
extern "C" {
    #[doc = "Creates an image without allocating memory for the image (used in the new version of the library).\n# Arguments\n\n* `numcmpts` -    the number of components\n* `cmptparms` -   the components parameters\n* `clrspc` -      the image color space\n# Returns\n\na new image structure if successful, NULL otherwise."]
    pub fn opj_image_tile_create(
        numcmpts: OPJ_UINT32,
        cmptparms: *mut opj_image_cmptparm_t,
        clrspc: OPJ_COLOR_SPACE,
    ) -> *mut opj_image_t;
}
extern "C" {
    #[doc = "Allocator for opj_image_t->comps[].data\nTo be paired with opj_image_data_free.\n# Arguments\n\n* `size` -    number of bytes to allocate\n# Returns\n\na new pointer if successful, NULL otherwise.\n> **Since** 2.2.0"]
    pub fn opj_image_data_alloc(size: OPJ_SIZE_T) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Destructor for opj_image_t->comps[].data\nTo be paired with opj_image_data_alloc.\n# Arguments\n\n* `ptr` -    Pointer to free\n> **Since** 2.2.0"]
    pub fn opj_image_data_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream.\n# Arguments\n\n* `p_is_input` -      if set to true then the stream will be an input stream, an output stream else.\n# Returns\n\na stream object."]
    pub fn opj_stream_default_create(p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = "Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream.\n# Arguments\n\n* `p_buffer_size` -  FIXME DOC\n* `p_is_input` -      if set to true then the stream will be an input stream, an output stream else.\n# Returns\n\na stream object."]
    pub fn opj_stream_create(p_buffer_size: OPJ_SIZE_T, p_is_input: OPJ_BOOL) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = "Destroys a stream created by opj_create_stream. This function does NOT close the abstract stream. If needed the user must\nclose its own implementation of the stream.\n# Arguments\n\n* `p_stream` -    the stream to destroy."]
    pub fn opj_stream_destroy(p_stream: *mut opj_stream_t);
}
extern "C" {
    #[doc = "Sets the given function to be used as a read function.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `p_function` -  the function to use a read function."]
    pub fn opj_stream_set_read_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_read_fn,
    );
}
extern "C" {
    #[doc = "Sets the given function to be used as a write function.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `p_function` -  the function to use a write function."]
    pub fn opj_stream_set_write_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_write_fn,
    );
}
extern "C" {
    #[doc = "Sets the given function to be used as a skip function.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `p_function` -  the function to use a skip function."]
    pub fn opj_stream_set_skip_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_skip_fn,
    );
}
extern "C" {
    #[doc = "Sets the given function to be used as a seek function, the stream is then seekable,\nusing SEEK_SET behavior.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `p_function` -  the function to use a skip function."]
    pub fn opj_stream_set_seek_function(
        p_stream: *mut opj_stream_t,
        p_function: opj_stream_seek_fn,
    );
}
extern "C" {
    #[doc = "Sets the given data to be used as a user data for the stream.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `p_data` -      the data to set.\n* `p_function` -  the function to free p_data when opj_stream_destroy() is called."]
    pub fn opj_stream_set_user_data(
        p_stream: *mut opj_stream_t,
        p_data: *mut ::std::os::raw::c_void,
        p_function: opj_stream_free_user_data_fn,
    );
}
extern "C" {
    #[doc = "Sets the length of the user data for the stream.\n# Arguments\n\n* `p_stream` -    the stream to modify\n* `data_length` - length of the user_data."]
    pub fn opj_stream_set_user_data_length(p_stream: *mut opj_stream_t, data_length: OPJ_UINT64);
}
extern "C" {
    #[doc = "Create a stream from a file identified with its filename with default parameters (helper function)\n# Arguments\n\n* `fname` -             the filename of the file to stream\n* `p_is_read_stream` -  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_default_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = "Create a stream from a file identified with its filename with a specific buffer size\n# Arguments\n\n* `fname` -             the filename of the file to stream\n* `p_buffer_size` -     size of the chunk used to stream\n* `p_is_read_stream` -  whether the stream is a read stream (true) or not (false)"]
    pub fn opj_stream_create_file_stream(
        fname: *const ::std::os::raw::c_char,
        p_buffer_size: OPJ_SIZE_T,
        p_is_read_stream: OPJ_BOOL,
    ) -> *mut opj_stream_t;
}
extern "C" {
    #[doc = "Set the info handler use by openjpeg.\n# Arguments\n\n* `p_codec` -       the codec previously initialise\n* `p_callback` -    the callback function which will be used\n* `p_user_data` -   client object where will be returned the message"]
    pub fn opj_set_info_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Set the warning handler use by openjpeg.\n# Arguments\n\n* `p_codec` -       the codec previously initialise\n* `p_callback` -    the callback function which will be used\n* `p_user_data` -   client object where will be returned the message"]
    pub fn opj_set_warning_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Set the error handler use by openjpeg.\n# Arguments\n\n* `p_codec` -       the codec previously initialise\n* `p_callback` -    the callback function which will be used\n* `p_user_data` -   client object where will be returned the message"]
    pub fn opj_set_error_handler(
        p_codec: *mut opj_codec_t,
        p_callback: opj_msg_callback,
        p_user_data: *mut ::std::os::raw::c_void,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Creates a J2K/JP2 decompression structure\n# Arguments\n\n* `format` -        Decoder to select\n# Returns\n\nReturns a handle to a decompressor if successful, returns NULL otherwise"]
    pub fn opj_create_decompress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = "Destroy a decompressor handle\n# Arguments\n\n* `p_codec` -         decompressor handle to destroy"]
    pub fn opj_destroy_codec(p_codec: *mut opj_codec_t);
}
extern "C" {
    #[doc = "Read after the codestream if necessary\n# Arguments\n\n* `p_codec` -         the JPEG2000 codec to read.\n* `p_stream` -        the JPEG2000 stream."]
    pub fn opj_end_decompress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Set decoding parameters to default values\n# Arguments\n\n* `parameters` - Decompression parameters"]
    pub fn opj_set_default_decoder_parameters(parameters: *mut opj_dparameters_t);
}
extern "C" {
    #[doc = "Setup the decoder with decompression parameters provided by the user and with the message handler\nprovided by the user.\n# Arguments\n\n* `p_codec` -       decompressor handler\n* `parameters` -    decompression parameters\n# Returns\n\ntrue         if the decoder is correctly set"]
    pub fn opj_setup_decoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_dparameters_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Set strict decoding parameter for this decoder.  If strict decoding is enabled, partial bit\nstreams will fail to decode.  If strict decoding is disabled, the decoder will decode partial\nbitstreams as much as possible without erroring\n# Arguments\n\n* `p_codec` -       decompressor handler\n* `strict` -        OPJ_TRUE to enable strict decoding, OPJ_FALSE to disable\n# Returns\n\ntrue         if the decoder is correctly set"]
    pub fn opj_decoder_set_strict_mode(p_codec: *mut opj_codec_t, strict: OPJ_BOOL) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Allocates worker threads for the compressor/decompressor.\nBy default, only the main thread is used. If this function is not used,\nbut the OPJ_NUM_THREADS environment variable is set, its value will be\nused to initialize the number of threads. The value can be either an integer\nnumber, or \"ALL_CPUS\". If OPJ_NUM_THREADS is set and this function is called,\nthis function will override the behaviour of the environment variable.\nThis function must be called after opj_setup_decoder() and\nbefore opj_read_header() for the decoding side, or after opj_setup_encoder()\nand before opj_start_compress() for the encoding side.\n# Arguments\n\n* `p_codec` -       decompressor or compressor handler\n* `num_threads` -   number of threads.\n# Returns\n\nOPJ_TRUE     if the function is successful."]
    pub fn opj_codec_set_threads(
        p_codec: *mut opj_codec_t,
        num_threads: ::std::os::raw::c_int,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Decodes an image header.\n# Arguments\n\n* `p_stream` -        the jpeg2000 stream.\n* `p_codec` -         the jpeg2000 codec to read.\n* `p_image` -         the image structure initialized with the characteristics of encoded image.\n# Returns\n\ntrue             if the main header of the codestream and the JP2 header is correctly read."]
    pub fn opj_read_header(
        p_stream: *mut opj_stream_t,
        p_codec: *mut opj_codec_t,
        p_image: *mut *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Restrict the number of components to decode.\nThis function should be called after opj_read_header().\nThis function enables to restrict the set of decoded components to the\nspecified indices.\nNote that the current implementation (apply_color_transforms == OPJ_FALSE)\nis such that neither the multi-component transform at codestream level,\nnor JP2 channel transformations will be applied.\nConsequently the indices are relative to the codestream.\nNote: opj_decode_tile_data() should not be used together with opj_set_decoded_components().\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec to read.\n* `numcomps` -        Size of the comps_indices array.\n* `comps_indices` -   Array of numcomps values representing the indices\nof the components to decode (relative to the\ncodestream, starting at 0)\n* `apply_color_transforms` - Whether multi-component transform at codestream level\nor JP2 channel transformations should be applied.\nCurrently this parameter should be set to OPJ_FALSE.\nSetting it to OPJ_TRUE will result in an error.\n# Returns\n\nOPJ_TRUE         in case of success."]
    pub fn opj_set_decoded_components(
        p_codec: *mut opj_codec_t,
        numcomps: OPJ_UINT32,
        comps_indices: *const OPJ_UINT32,
        apply_color_transforms: OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading.\nThe coordinates passed to this function should be expressed in the reference grid,\nthat is to say at the highest resolution level, even if requesting the image at lower\nresolution levels.\nGenerally opj_set_decode_area() should be followed by opj_decode(), and the\ncodec cannot be re-used.\nIn the particular case of an image made of a single tile, several sequences of\ncalls to opoj_set_decode_area() and opj_decode() are allowed, and will bring\nperformance improvements when reading an image by chunks.\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `p_image` -         the decoded image previously set by opj_read_header\n* `p_start_x` -       the left position of the rectangle to decode (in image coordinates).\n* `p_end_x` -         the right position of the rectangle to decode (in image coordinates).\n* `p_start_y` -       the up position of the rectangle to decode (in image coordinates).\n* `p_end_y` -         the bottom position of the rectangle to decode (in image coordinates).\n# Returns\n\ntrue            if the area could be set."]
    pub fn opj_set_decode_area(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_start_x: OPJ_INT32,
        p_start_y: OPJ_INT32,
        p_end_x: OPJ_INT32,
        p_end_y: OPJ_INT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Decode an image from a JPEG-2000 codestream\n# Arguments\n\n* `p_decompressor` -    decompressor handle\n* `p_stream` -          Input buffer stream\n* `p_image` -           the decoded image\n# Returns\n\ntrue if success, otherwise false"]
    pub fn opj_decode(
        p_decompressor: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Get the decoded tile from the codec\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `p_stream` -        input stream\n* `p_image` -         output image\n* `tile_index` -      index of the tile which will be decode\n# Returns\n\ntrue if success, otherwise false"]
    pub fn opj_get_decoded_tile(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_image: *mut opj_image_t,
        tile_index: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Set the resolution factor of the decoded image\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `res_factor` -      resolution factor to set\n# Returns\n\ntrue if success, otherwise false"]
    pub fn opj_set_decoded_resolution_factor(
        p_codec: *mut opj_codec_t,
        res_factor: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Writes a tile with the given data.\n# Arguments\n\n* `p_codec` -             the jpeg2000 codec.\n* `p_tile_index` -        the index of the tile to write. At the moment, the tiles must be written from 0 to n-1 in sequence.\n* `p_data` -              pointer to the data to write. Data is arranged in sequence, data_comp0, then data_comp1, then ... NO INTERLEAVING should be set.\n* `p_data_size` -         this value os used to make sure the data being written is correct. The size must be equal to the sum for each component of\ntile_width * tile_height * component_size. component_size can be 1,2 or 4 bytes, depending on the precision of the given component.\n* `p_stream` -            the stream to write data to.\n# Returns\n\ntrue if the data could be written."]
    pub fn opj_write_tile(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Reads a tile header. This function is compulsory and allows one to know the size of the tile that will be decoded.\nThe user may need to refer to the image got by opj_read_header to understand the size being taken by the tile.\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `p_tile_index` -    pointer to a value that will hold the index of the tile being decoded, in case of success.\n* `p_data_size` -     pointer to a value that will hold the maximum size of the decoded data, in case of success. In case\nof truncated codestreams, the actual number of bytes decoded may be lower. The computation of the size is the same\nas depicted in opj_write_tile.\n* `p_tile_x0` -       pointer to a value that will hold the x0 pos of the tile (in the image).\n* `p_tile_y0` -       pointer to a value that will hold the y0 pos of the tile (in the image).\n* `p_tile_x1` -       pointer to a value that will hold the x1 pos of the tile (in the image).\n* `p_tile_y1` -       pointer to a value that will hold the y1 pos of the tile (in the image).\n* `p_nb_comps` -      pointer to a value that will hold the number of components in the tile.\n* `p_should_go_on` -  pointer to a boolean that will hold the fact that the decoding should go on. In case the\ncodestream is over at the time of the call, the value will be set to false. The user should then stop\nthe decoding.\n* `p_stream` -        the stream to decode.\n# Returns\n\ntrue            if the tile header could be decoded. In case the decoding should end, the returned value is still true.\nreturning false may be the result of a shortage of memory or an internal error."]
    pub fn opj_read_tile_header(
        p_codec: *mut opj_codec_t,
        p_stream: *mut opj_stream_t,
        p_tile_index: *mut OPJ_UINT32,
        p_data_size: *mut OPJ_UINT32,
        p_tile_x0: *mut OPJ_INT32,
        p_tile_y0: *mut OPJ_INT32,
        p_tile_x1: *mut OPJ_INT32,
        p_tile_y1: *mut OPJ_INT32,
        p_nb_comps: *mut OPJ_UINT32,
        p_should_go_on: *mut OPJ_BOOL,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Reads a tile data. This function is compulsory and allows one to decode tile data. opj_read_tile_header should be called before.\nThe user may need to refer to the image got by opj_read_header to understand the size being taken by the tile.\nNote: opj_decode_tile_data() should not be used together with opj_set_decoded_components().\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `p_tile_index` -    the index of the tile being decoded, this should be the value set by opj_read_tile_header.\n* `p_data` -          pointer to a memory block that will hold the decoded data.\n* `p_data_size` -     size of p_data. p_data_size should be bigger or equal to the value set by opj_read_tile_header.\n* `p_stream` -        the stream to decode.\n# Returns\n\ntrue            if the data could be decoded."]
    pub fn opj_decode_tile_data(
        p_codec: *mut opj_codec_t,
        p_tile_index: OPJ_UINT32,
        p_data: *mut OPJ_BYTE,
        p_data_size: OPJ_UINT32,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Creates a J2K/JP2 compression structure\n# Arguments\n\n* `format` -      Coder to select\n# Returns\n\nReturns a handle to a compressor if successful, returns NULL otherwise"]
    pub fn opj_create_compress(format: OPJ_CODEC_FORMAT) -> *mut opj_codec_t;
}
extern "C" {
    #[doc = "Set encoding parameters to default values, that means :\n<ul>\n<li>Lossless\n<li>1 tile\n<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)\n<li>Size of code-block : 64 x 64\n<li>Number of resolutions: 6\n<li>No SOP marker in the codestream\n<li>No EPH marker in the codestream\n<li>No sub-sampling in x or y direction\n<li>No mode switch activated\n<li>Progression order: LRCP\n<li>No index file\n<li>No ROI upshifted\n<li>No offset of the origin of the image\n<li>No offset of the origin of the tiles\n<li>Reversible DWT 5-3\n</ul>\n# Arguments\n\n* `parameters` - Compression parameters"]
    pub fn opj_set_default_encoder_parameters(parameters: *mut opj_cparameters_t);
}
extern "C" {
    #[doc = "Setup the encoder parameters using the current image and using user parameters.\n# Arguments\n\n* `p_codec` -       Compressor handle\n* `parameters` -    Compression parameters\n* `image` -         Input filled image"]
    pub fn opj_setup_encoder(
        p_codec: *mut opj_codec_t,
        parameters: *mut opj_cparameters_t,
        image: *mut opj_image_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Specify extra options for the encoder.\nThis may be called after opj_setup_encoder() and before opj_start_compress()\nThis is the way to add new options in a fully ABI compatible way, without\nextending the opj_cparameters_t structure.\nCurrently supported options are:\n<ul>\n<li>PLT=YES/NO. Defaults to NO. If set to YES, PLT marker segments,\nindicating the length of each packet in the tile-part header, will be\nwritten. Since 2.4.0</li>\n<li>TLM=YES/NO. Defaults to NO (except for Cinema and IMF profiles).\nIf set to YES, TLM marker segments, indicating the length of each\ntile-part part will be written. Since 2.4.0</li>\n<li>GUARD_BITS=value. Number of guard bits in [0,7] range. Default value is 2.\n1 may be used sometimes (like in SMPTE DCP Bv2.1 Application Profile for 2K images).\nSince 2.5.0</li>\n</ul>\n# Arguments\n\n* `p_codec` -       Compressor handle\n* `p_options` -     Compression options. This should be a NULL terminated\narray of strings. Each string is of the form KEY=VALUE.\n# Returns\n\nOPJ_TRUE in case of success.\n> **Since** 2.4.0"]
    pub fn opj_encoder_set_extra_options(
        p_codec: *mut opj_codec_t,
        p_options: *const *const ::std::os::raw::c_char,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Start to compress the current image.\n# Arguments\n\n* `p_codec` -       Compressor handle\n* `p_image` -       Input filled image\n* `p_stream` -      Input stgream"]
    pub fn opj_start_compress(
        p_codec: *mut opj_codec_t,
        p_image: *mut opj_image_t,
        p_stream: *mut opj_stream_t,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "End to compress the current image.\n# Arguments\n\n* `p_codec` -       Compressor handle\n* `p_stream` -      Input stgream"]
    pub fn opj_end_compress(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Encode an image into a JPEG-2000 codestream\n# Arguments\n\n* `p_codec` -       compressor handle\n* `p_stream` -      Output buffer stream\n# Returns\n\nReturns true if successful, returns false otherwise"]
    pub fn opj_encode(p_codec: *mut opj_codec_t, p_stream: *mut opj_stream_t) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Destroy Codestream information after compression or decompression\n# Arguments\n\n* `cstr_info` - Codestream information structure"]
    pub fn opj_destroy_cstr_info(cstr_info: *mut *mut opj_codestream_info_v2_t);
}
extern "C" {
    #[doc = "Dump the codec information into the output stream\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n* `info_flag` -       type of information dump.\n* `output_stream` -   output stream where dump the information gotten from the codec.\n"]
    pub fn opj_dump_codec(
        p_codec: *mut opj_codec_t,
        info_flag: OPJ_INT32,
        output_stream: *mut FILE,
    );
}
extern "C" {
    #[doc = "Get the codestream information from the codec\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n# Returns\n\na pointer to a codestream information structure.\n"]
    pub fn opj_get_cstr_info(p_codec: *mut opj_codec_t) -> *mut opj_codestream_info_v2_t;
}
extern "C" {
    #[doc = "Get the codestream index from the codec\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n# Returns\n\na pointer to a codestream index structure.\n"]
    pub fn opj_get_cstr_index(p_codec: *mut opj_codec_t) -> *mut opj_codestream_index_t;
}
extern "C" {
    pub fn opj_destroy_cstr_index(p_cstr_index: *mut *mut opj_codestream_index_t);
}
extern "C" {
    #[doc = "Get the JP2 file information from the codec FIXME\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n# Returns\n\na pointer to a JP2 metadata structure.\n"]
    pub fn opj_get_jp2_metadata(p_codec: *mut opj_codec_t) -> *mut opj_jp2_metadata_t;
}
extern "C" {
    #[doc = "Get the JP2 file index from the codec FIXME\n# Arguments\n\n* `p_codec` -         the jpeg2000 codec.\n# Returns\n\na pointer to a JP2 index structure.\n"]
    pub fn opj_get_jp2_index(p_codec: *mut opj_codec_t) -> *mut opj_jp2_index_t;
}
extern "C" {
    #[doc = "Sets the MCT matrix to use.\n# Arguments\n\n* `parameters` -      the parameters to change.\n* `pEncodingMatrix` - the encoding matrix.\n* `p_dc_shift` -      the dc shift coefficients to use.\n* `pNbComp` -         the number of components of the image.\n# Returns\n\ntrue if the parameters could be set."]
    pub fn opj_set_MCT(
        parameters: *mut opj_cparameters_t,
        pEncodingMatrix: *mut OPJ_FLOAT32,
        p_dc_shift: *mut OPJ_INT32,
        pNbComp: OPJ_UINT32,
    ) -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Returns if the library is built with thread support.\nOPJ_TRUE if mutex, condition, thread, thread pool are available."]
    pub fn opj_has_thread_support() -> OPJ_BOOL;
}
extern "C" {
    #[doc = "Return the number of virtual CPUs"]
    pub fn opj_get_num_cpus() -> ::std::os::raw::c_int;
}
